package com.huskerdev.plugins.maven


import com.fasterxml.jackson.databind.node.ArrayNode
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.gitee.pkmer.enums.PublishingType
import io.gitee.pkmer.extension.PkmerBootPluginExtension
import org.gradle.api.Action
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.attributes.Usage
import org.gradle.api.component.AdhocComponentWithVariants
import org.gradle.api.component.SoftwareComponent
import org.gradle.api.plugins.ExtraPropertiesExtension
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPom
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.tasks.PublishToMavenRepository
import org.gradle.api.publish.tasks.GenerateModuleMetadata
import org.gradle.kotlin.dsl.DependencyHandlerScope
import org.gradle.kotlin.dsl.get
import org.gradle.plugins.signing.SigningExtension

private const val customConfiguration = "silentApi"
private const val publicationName = "mavenJava"

@Suppress("unused")
class MavenPlugin: Plugin<Project> {

    override fun apply(project: Project) {
        project.pluginManager.apply("maven-publish")
        project.pluginManager.apply("signing")
        project.pluginManager.apply("io.gitee.pkmer.pkmerboot-central-publisher")

        val component = if(project.plugins.hasPlugin("java-platform"))
            project.components["javaPlatform"] else
            project.components["java"]

        addCustomConfiguration(project, customConfiguration, component)

        project.afterEvaluate {
            project.publishing {
                publications {
                    create(publicationName, MavenPublication::class.java) {
                        from(component)
                        project.configurePom(pom)
                        artifactId = pom.name.getOrElse("")
                        groupId = project.group.toString()
                    }
                }
                repositories {
                    maven {
                        name = "Local"
                        url = project.uri(project.layout.buildDirectory.dir("repos/bundles"))
                    }
                }
            }
        }

        project.signing {
            setRequired {
                project.gradle.taskGraph.allTasks.any { it is PublishToMavenRepository }
            }
            if(project.hasProperty("ossrhUsername"))
                sign(project.publishing.publications)
        }

        project.pkmerBoot {
            sonatypeMavenCentral{
                stagingRepository.set(project.layout.buildDirectory.dir("repos/bundles"))

                username.set(project.properties["ossrhUsername"].toString())
                password.set(project.properties["ossrhPassword"].toString())

                publishingType.set(PublishingType.USER_MANAGED)
            }
        }
    }


    /**
     * Creates custom configuration to include in .pom
     */
    private fun addCustomConfiguration(project: Project, name: String, component: SoftwareComponent){
        val silentApi = project.configurations.create(name) {
            attributes {
                attribute(Usage.USAGE_ATTRIBUTE, project.objects.named(Usage::class.java, "java-api"))
            }
        }

        component as AdhocComponentWithVariants
        component.addVariantsFromConfiguration(silentApi) {
            mapToMavenScope("compile")
        }

        // Edit .module file, generated by gradle - adding pomOnlyCompile dependencies to apiElements
        project.tasks.withType(GenerateModuleMetadata::class.java) {
            doLast {
                val moduleJson = jacksonObjectMapper().readTree(outputFile.get().asFile.readText())
                val variants = moduleJson["variants"] as ArrayNode

                val apiElements = variants.first { it["name"].asText() == "apiElements" }
                val runtimeElements = variants.first { it["name"].asText() == "runtimeElements" }
                val customVariant = variants.first { it["name"].asText() == name }

                if(customVariant.has("dependencies")) {
                    val apiDeps = apiElements["dependencies"] as ArrayNode
                    val runtimeDeps = runtimeElements["dependencies"] as ArrayNode
                    val customDeps = customVariant["dependencies"] as ArrayNode

                    apiDeps.addAll(customDeps)
                    runtimeDeps.addAll(customDeps)
                    variants.remove(variants.indexOf(customVariant))

                    val text = jacksonObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(moduleJson)
                    outputFile.get().asFile.writeText(text)
                }
            }
        }
    }
}

@Suppress("unchecked_cast")
private fun Project.configurePom(pom: MavenPom) {
    val projects = arrayListOf(this)

    while(projects.last().parent != null)
        projects += projects.last().parent!!

    projects.reversed().forEach {
        if(it.ext.has("pom"))
            (it.ext["pom"] as Action<MavenPom>).execute(pom)
    }
}

private val Project.ext
    get() = this.extensions.getByType(ExtraPropertiesExtension::class.java)

private val Project.publishing
    get() = project.extensions.findByType(PublishingExtension::class.java)!!

private fun Project.publishing(block: PublishingExtension.() -> Unit) =
    publishing.apply(block)

private fun Project.pkmerBoot(block: PkmerBootPluginExtension.() -> Unit) =
    project.extensions.getByType(PkmerBootPluginExtension::class.java).apply(block)

private fun Project.signing(block: SigningExtension.() -> Unit) =
    project.extensions.getByType(SigningExtension::class.java).apply(block)

fun DependencyHandlerScope.silentApi(string: String) =
    add(customConfiguration, string)
